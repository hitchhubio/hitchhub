{"version":3,"sources":["../src/types.ts","../src/is-alias.ts","../src/alias-to-path.ts","../src/flatten-composite-alias.ts","../src/is-path.ts","../src/alias-join.ts","../src/flatten-composite.ts","../src/get-value.ts"],"sourcesContent":["export type Token = {\n  $type: string;\n  $value: unknown;\n};\n\nexport type CompositeToken = {\n  $type: string;\n  $value: Record<string, unknown>;\n};\n\nexport function isObject(value: unknown): value is Record<string, unknown> {\n  return value !== null && typeof value === 'object';\n}\n\nexport function isToken(value: unknown): value is Token {\n  return isObject(value) && '$type' in value && '$value' in value;\n}\n\nexport function isCompositeToken(value: unknown): value is CompositeToken {\n  return isToken(value) && isObject(value.$value);\n}\n","import { isObject } from './types.js';\n\nexport function isAlias(value: unknown) {\n  const regex = /{([^}]+)}/g;\n\n  if (typeof value === 'string') {\n    return regex.test(value);\n  }\n\n  if (isObject(value)) {\n    let hasAlias = false;\n\n    for (const key in value) {\n      if (Object.prototype.hasOwnProperty.call(value, key)) {\n        const element = value[key];\n        const alias = isAlias(element);\n\n        if (alias) {\n          hasAlias = true;\n          break;\n        }\n      }\n    }\n\n    return hasAlias;\n  }\n\n  return false;\n}\n","import { isAlias } from './is-alias.js';\n\nexport function pathToAlias(path: string) {\n  return `{${path}}`;\n}\n\nexport function aliasToPath(alias: string) {\n  if (!isAlias(alias)) {\n    throw new Error(`Invalid alias '${alias}'.`);\n  }\n\n  return alias.replace('{', '').replace('}', '');\n}\n","import { objectKeys } from 'ts-extras';\nimport { aliasJoin } from './alias-join.js';\nimport { CompositeToken, Token } from './types.js';\n\nexport function flattenCompositeAlias({\n  alias,\n  aliasedValue,\n  resolveType,\n}: {\n  alias: string;\n  aliasedValue: CompositeToken;\n  resolveType: (key: string) => string | undefined;\n}): Record<string, Token> {\n  return objectKeys(aliasedValue.$value).reduce(\n    (accumulator, key) => {\n      const type = resolveType(key);\n\n      if (type == null) {\n        throw new Error(`No type defined composite value key '${key}'.`);\n      }\n\n      accumulator[key] = {\n        $type: type,\n        $value: aliasJoin(alias, key),\n      };\n\n      return accumulator;\n    },\n    {} as Record<string, Token>,\n  );\n}\n","export function isPath(value: unknown) {\n  if (typeof value === 'string') {\n    return /^[A-Za-z|]+(\\.[A-Za-z|]+)*$/.test(value);\n  }\n  return false;\n}\n","import { aliasToPath, pathToAlias } from './alias-to-path.js';\nimport { isAlias } from './is-alias.js';\nimport { isPath } from './is-path.js';\n\nexport function aliasJoin(...parts: string[]): string {\n  const paths = parts.map((part) => {\n    if (isAlias(part)) {\n      return aliasToPath(part);\n    }\n\n    if (isPath(part)) {\n      return part;\n    }\n\n    throw new Error(`Invalid part '${part}'.`);\n  });\n\n  return pathToAlias(paths.join('.'));\n}\n","import { objectKeys } from 'ts-extras';\nimport { CompositeToken, Token } from './types.js';\n\nexport function flattenComposite({\n  value,\n  resolveType,\n}: {\n  value: CompositeToken;\n  resolveType: (key: string) => string | undefined;\n}): Record<string, Token> {\n  return objectKeys(value.$value).reduce(\n    (accumulator, key) => {\n      const type = resolveType(key);\n\n      if (type == null) {\n        throw new Error(`No type defined composite value key '${key}'.`);\n      }\n\n      accumulator[key] = {\n        $type: type,\n        $value: value.$value[key],\n      };\n\n      return accumulator;\n    },\n    {} as Record<string, Token>,\n  );\n}\n","import get from 'lodash/get.js';\n\nexport function getValue<T>({\n  value,\n  path,\n  defaultValue,\n}: {\n  value: Record<string, unknown>;\n  path: string;\n  defaultValue?: T;\n}): T {\n  return get(value, path, defaultValue) as T;\n}\n"],"mappings":"AAUO,SAASA,EAASC,EAAkD,CACzE,OAAOA,IAAU,MAAQ,OAAOA,GAAU,QAC5C,CAEO,SAASC,EAAQD,EAAgC,CACtD,OAAOD,EAASC,CAAK,GAAK,UAAWA,GAAS,WAAYA,CAC5D,CAEO,SAASE,EAAiBF,EAAyC,CACxE,OAAOC,EAAQD,CAAK,GAAKD,EAASC,EAAM,MAAM,CAChD,CClBO,SAASG,EAAQC,EAAgB,CACtC,IAAMC,EAAQ,aAEd,GAAI,OAAOD,GAAU,SACnB,OAAOC,EAAM,KAAKD,CAAK,EAGzB,GAAIE,EAASF,CAAK,EAAG,CACnB,IAAIG,EAAW,GAEf,QAAWC,KAAOJ,EAChB,GAAI,OAAO,UAAU,eAAe,KAAKA,EAAOI,CAAG,EAAG,CACpD,IAAMC,EAAUL,EAAMI,CAAG,EAGzB,GAFcL,EAAQM,CAAO,EAElB,CACTF,EAAW,GACX,KACF,CACF,CAGF,OAAOA,CACT,CAEA,MAAO,EACT,CC1BO,SAASG,EAAYC,EAAc,CACxC,MAAO,IAAIA,CAAI,GACjB,CAEO,SAASC,EAAYC,EAAe,CACzC,GAAI,CAACC,EAAQD,CAAK,EAChB,MAAM,IAAI,MAAM,kBAAkBA,CAAK,IAAI,EAG7C,OAAOA,EAAM,QAAQ,IAAK,EAAE,EAAE,QAAQ,IAAK,EAAE,CAC/C,CCZA,OAAS,cAAAE,MAAkB,YCApB,SAASC,EAAOC,EAAgB,CACrC,OAAI,OAAOA,GAAU,SACZ,8BAA8B,KAAKA,CAAK,EAE1C,EACT,CCDO,SAASC,KAAaC,EAAyB,CACpD,IAAMC,EAAQD,EAAM,IAAKE,GAAS,CAChC,GAAIC,EAAQD,CAAI,EACd,OAAOE,EAAYF,CAAI,EAGzB,GAAIG,EAAOH,CAAI,EACb,OAAOA,EAGT,MAAM,IAAI,MAAM,iBAAiBA,CAAI,IAAI,CAC3C,CAAC,EAED,OAAOI,EAAYL,EAAM,KAAK,GAAG,CAAC,CACpC,CFdO,SAASM,EAAsB,CACpC,MAAAC,EACA,aAAAC,EACA,YAAAC,CACF,EAI0B,CACxB,OAAOC,EAAWF,EAAa,MAAM,EAAE,OACrC,CAACG,EAAaC,IAAQ,CACpB,IAAMC,EAAOJ,EAAYG,CAAG,EAE5B,GAAIC,GAAQ,KACV,MAAM,IAAI,MAAM,wCAAwCD,CAAG,IAAI,EAGjE,OAAAD,EAAYC,CAAG,EAAI,CACjB,MAAOC,EACP,OAAQC,EAAUP,EAAOK,CAAG,CAC9B,EAEOD,CACT,EACA,CAAC,CACH,CACF,CG9BA,OAAS,cAAAI,MAAkB,YAGpB,SAASC,EAAiB,CAC/B,MAAAC,EACA,YAAAC,CACF,EAG0B,CACxB,OAAOH,EAAWE,EAAM,MAAM,EAAE,OAC9B,CAACE,EAAaC,IAAQ,CACpB,IAAMC,EAAOH,EAAYE,CAAG,EAE5B,GAAIC,GAAQ,KACV,MAAM,IAAI,MAAM,wCAAwCD,CAAG,IAAI,EAGjE,OAAAD,EAAYC,CAAG,EAAI,CACjB,MAAOC,EACP,OAAQJ,EAAM,OAAOG,CAAG,CAC1B,EAEOD,CACT,EACA,CAAC,CACH,CACF,CC3BA,OAAOG,MAAS,gBAET,SAASC,EAAY,CAC1B,MAAAC,EACA,KAAAC,EACA,aAAAC,CACF,EAIM,CACJ,OAAOJ,EAAIE,EAAOC,EAAMC,CAAY,CACtC","names":["isObject","value","isToken","isCompositeToken","isAlias","value","regex","isObject","hasAlias","key","element","pathToAlias","path","aliasToPath","alias","isAlias","objectKeys","isPath","value","aliasJoin","parts","paths","part","isAlias","aliasToPath","isPath","pathToAlias","flattenCompositeAlias","alias","aliasedValue","resolveType","objectKeys","accumulator","key","type","aliasJoin","objectKeys","flattenComposite","value","resolveType","accumulator","key","type","get","getValue","value","path","defaultValue"]}